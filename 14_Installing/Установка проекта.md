
---

Итоговый продукт любой разработки почти всегда представляет из себя целую систему связанных элементов, и не всегда удобно или возможно создавать на его основе пакет. Для распространения и использовании итогового продукта необходимо предусмотреть возможность «работы из коробки» исполняемых файлов и сопутствующих данных (в частности, доступ к документации). Несомненно, существует вариант распространения «чистых» исходников (через публичные репозитории, например), однако такой вариант требует от пользователя знаний и умений для донастройки (если не перенастройки) всех связей при ручной сборке и установке. Кроме этого могут возникнуть проблемы, связанные с недостатком библиотек или необходимых для сборки утилит.
## Варианты установки

Прежде всего заметим, что наиболее надёжный вариант установки ПО в систему — это _пакет_ собранный в эту систему сообразно дисциплине сообщества. Использование Hasher и Gear делают результат RPM-пакета ещё более совместимым. Главный недостаток пакета, созданного по всем правилам — его необходимо _сопровождать_, то есть пересматривать работоспособность с каждым обновлением, затрагивающим его зависимости, пересобирать и исправлять в случае чего и т. д.

Какими неприятностями грозят «классические» варианты установки свежесобранного ПО по алгоритму «крибле! крабле! бумс!», то есть `./configure`, `make`, `make install`?

Установка в соответствии со _стандартом иерархии файлов_ в файловой системе ([Filesystem_Hierarchy_Standard](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard)), которую мы использовали для сборки пакета, предполагает, что исполняемые файлы устанавливаются в системный каталог `/usr/bin`, библиотеки — в `/usr/lib64`, документация — в `/usr/share/doc` и т. д. Установка в системные директории согласно FHS гарантирует работу устанавливаемого ПО, поскольку работа со всеми системными утилитами настроена под именно такое распределение файлов. С точки зрения разработчика у такого способа есть важный недостаток: размещение файлов в системных каталогах — это вмешательство в архитектуру ОС. Оно требует прав суперпользователя (даже если задача — просто потестировать очередной вариант сборки) и возлагает на программиста несвойственную ему ответственность за возможные файловые конфликты. Например, назвал программист свою программу «kitten» (котёнок) — что может пойти не так? А нет, в системе есть пакет с файлом `/usr/bin/kitten`, который заменился при установке.

Для избежания конфликтов с системой появился метод установки в директории `/usr/local/`. В традиционных Linux-дистрибутивах дерево каталогов в `/usr/local` не используется, но при этом каталоги `/usr/local/bin`, `/usr/local/lib64`, `/usr/local/share/man` и т. п. считаются стандартными местами для размещения файлов соответствующего типа. Устанавливаемое туда ПО не конфликтует с базовой системой, и именно этот способ включится по умолчанию в GNU Autotools, если отдельно не задать префикс установки. В FHS каталог `/usr/local` предназначен для т. н. «локальной установки» ПО, что частично совпадает с нашей целью, а частично  — нет. Для установки в `/usr/local` нужно иметь права суперпользователя, и продолжать следить за файловыми конфликтами устанавливаемых проектов _между собой_.

Гарантированно не вызывающий конфликтов способ установки — использование для каждого приложения уникального расположения в файловой системе. Такой способ возможен при установке в уникальную директорию `/opt/<AppName>/`. Для установки всё ещё требуются права суперпользователя, хотя это уже не обязательно, достаточно программисту выдать отдельный доступный подкаталог. Данный способ позволяет избежать файловых конфликтов. Основной недостаток такого способа — необходимость явного указания в `$PATH` `/bin`-директории с устанавливаемым приложением для его запуска. Что ещё важнее — подгружать динамические библиотеки из `/opt/<AppName>/lib` необходимо вручную — как минимум, дополнять путь загрузки с помощью `LD_LIBRARY_PATH`. Следовательно, исполняемый файл в такой установке должен сопровождаться shell-сценарием с соответствующей настойкой. Кроме того, согласно дисциплине ALT динамическое изменение параметров запуска приложений, включая `LD_LIBRARY_PATH`, `LD_PRELOAD`, не заработает для SUID/SGID программ из соображений безопасности. Такая схема установки часто используется в сложных проектах, в состав которых входит большое количество собственных библиотек (в том числе совпадающих по именам с системными, но модифицированных).

Время от времени разработчикам таких проектов приходит в голову, например, добавить `/opt/<AppName>/lib` в настройки [динамического компоновщика](https://man7.org/linux/man-pages/man8/ld.so.8.html) — практика показывает, что это опасная идея: не ровен час, сторонняя библиотека заместит системную…

Для установки без прав суперпользователя располагать файлы можно в подкаталогах `$HOME/.local/`. Такие установки являются локальными для конкретного пользователя, что может приводить к установке в одну систему нескольких копий одних и тех же приложений. Также установка в локальное пространство пользователя требует полной настройки зависимостей на другие локальные установки. Такой способ полезен для систем, ориентированных на разработчика, поскольку при разработке часто требуется отдельное (а иногда и не одно) независимое пространство установки, и для него требуется ещё более замысловатая настройка путей для загрузки динамических библиотек (в которых появляется непостоянный компонент `$HOME`), наподобие той, что реализована в GNU Libtool.

Все схемы установки в специализированные директории файловой системы связаны с необходимостью дополнительно настраивать динамическую компоновку с библиотеками, входящими в состав проекта. Проблему можно решить _полностью статической_ сборкой и компоновкой. В результате получается статический же исполняемый файл. Статические прогарммы не требуют для запуска никаких библиотек, даже GLibC — только поддержку ядром загружаемого формата ELF. Такие программы можно просто _скопировать_ в произвольную Linux-систему, и они там заработают. Например, тремя статически собранными пакетами — `ash-static`, `cpio-static` и `find-static` — пользуется hasher для того, чтобы развернуть изолированное сборочное окружение в [chroot](https://www.altlinux.org/Chroot)-каталоге, в котором изначально нет вообще ничего.

`@user`
```console
[user@VM ~] rpmquery -f /usr/bin/cpio /usr/bin/cpio.static
cpio-2.15-alt1.x86_64
cpio-static-2.15-alt1.x86_64
[user@VM ~] file /usr/bin/cpio /usr/bin/cpio.static
/usr/bin/cpio:        ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d6dff4c6e0de24cd3c1334b152efcc5ebf89694a, for GNU/Linux 3.2.0, stripped
/usr/bin/cpio.static: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=e047490a73892cb9e762b0e409c73ea774c51ce9, for GNU/Linux 3.2.0, stripped
[user@VM ~] ldd /usr/bin/cpio /usr/bin/cpio.static
/usr/bin/cpio:
        linux-vdso.so.1 (0x00007f8786626000)
        libc.so.6 => /lib64/libc.so.6 (0x00007f87863de000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f8786628000)
/usr/bin/cpio.static:
        not a dynamic executable

```

Если программа разрабатывается для запуска в каком-то предсказуемом окружении, можно понадеяться на то, что в системе будут доступны стандартные библиотеки с определённым диапазоном версий. Это позволит не «таскать с собой» как минимум тот же `libc`, а при удачном стечении обстоятельств — отказаться и от базовых прикладных инструментариев, таких как Qt или GTK. При этом часть библиотек всё-таки собирается, для удобства — статически. Как правило это библиотеки собственной разработки и сторонние библиотеки, требующие модификации в составе проекта, и какая-нибудь сугубая редкость, надеяться на наличие которой в системе не имеет смысла. Напомним, что разговор идёт возможности установки «по месту», а не о _пакете_, в котором такая «редкость» просто ставится в зависимость. В последнее время стало популярно скачивать собирать из исходных текстов в составе проекта практически все сторонние компоненты. Такой подход называется «вендоринг», и он принят как основной в экосистемах языков Go и Rust.

Программа с завендоренными сторонними компонентами получается довольно большой, версии этих компонент отличаются от сборки к сборке, а получившийся исполняемый файл компонуется динамически, но зависит от минимума системных библиотек (часто — от одной только `libc`).


## Управление установкой с помощью Autotools

Autotools непосредственно поддерживает возможность установки проектов в систему. По умолчанию за установочный путь принят `/usr/local`. Автоматически сгенерированные рецепты `make install` самостоятельно распределяют все компоненты по поддиректориям. Однако, как было сказано ранее, установка в `/usr/local`, во-первых, требует прав суперпользователя:

`@user`
```console
[user@VM syscall-master]$ autoreconf -fisv
<...>
[user@VM syscall-master]$ ./configure
<...>
[user@VM syscall-master]$ make install
Making install in src
<...>
/usr/bin/mkdir -p '/usr/local/lib'
/bin/sh ../libtool   --mode=install /usr/bin/ginstall -c   libsyscall.la '/usr/local/lib'
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.so.0.0.0 /usr/local/lib/libsyscall.so.0.0.0
/usr/bin/ginstall: cannot create regular file '/usr/local/lib/libsyscall.so.0.0.0': Permission denied
<...>
[user@VM syscall-master]$ tree /usr/local
/usr/local
├── bin
│   └── hypersh
├── doc
├── etc
├── games
├── include
├── lib
├── lib64
├── libexec
├── libx32
├── man
├── sbin
└── share
   ├── info
   └── man

15 directories, 1 file
```

Ещё раз напоминаем, что при работе с правами суперпользователя нужно быть особенно бдительным!

```console
[root@VM ~]# cd /home/user/syscall-master/
[root@VM syscall-master]# make install
Making install in src
<...>
/usr/bin/mkdir -p '/usr/local/lib'
/bin/sh ../libtool   --mode=install /usr/bin/ginstall -c   libsyscall.la '/usr/local/lib'
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.so.0.0.0 /usr/local/lib/libsyscall.so.0.0.0
libtool: install: (cd /usr/local/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so.0 || { rm -f libsyscall.so.0 && ln -s libsyscall.so.0.0.0 libsyscall.so.0; }; })
libtool: install: (cd /usr/local/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so || { rm -f libsyscall.so && ln -s libsyscall.so.0.0.0 libsyscall.so; }; })
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.lai /usr/local/lib/libsyscall.la
/usr/bin/mkdir -p '/usr/local/bin'
 /bin/sh ../libtool   --mode=install /usr/bin/ginstall -c syscall '/usr/local/bin'
libtool: install: /usr/bin/ginstall -c .libs/syscall /usr/local/bin/syscall
/usr/bin/mkdir -p '/usr/local/share/man/man1'
/usr/bin/ginstall -c -m 644 syscall.1 '/usr/local/share/man/man1'

[root@VM syscall-master]# tree /usr/local
/usr/local
├── bin
│   ├── hypersh
│   └── syscall
├── doc
├── etc
├── games
├── include
├── lib
│   ├── libsyscall.la
│   ├── libsyscall.so -> libsyscall.so.0.0.0
│   ├── libsyscall.so.0 -> libsyscall.so.0.0.0
│   └── libsyscall.so.0.0.0
├── lib64
├── libexec
├── libx32
├── man
├── sbin
└── share
   ├── info
   └── man
       └── man1
           └── syscall.1

16 directories, 8 files
[root@VM syscall-master]#
```

Во-вторых, `/usr/local` не является единственным местом установки даже среди общепринятых. Более того, никто не ограничивает пользователя, разбирающегося в собственных действиях, производить установку в _любые_ места системы с оговоркой готовности пользователя самостоятельно настраивать загрузку динамических библиотек.

Для явного указания места установки проекта среди параметров `configure` существует ключ `--prefix=`, использующийся для указания места установки программы:

```console
[user@VM syscall-master]$ tree /tmp/
/tmp/
├── systemd-private-cf21b62e498d45469bbfe8c619515c2b-chronyd.service-1UNCOt  [error opening dir]
└── systemd-private-cf21b62e498d45469bbfe8c619515c2b-systemd-logind.service-pFMnpU  [error opening dir]

3 directories, 0 files
[user@VM syscall-master]$ ./configure --prefix=/tmp/qq
<...>
[user@VM syscall-master]$ make install
Making install in src
<...>
/bin/sh ../libtool   --mode=install /usr/bin/ginstall -c   libsyscall.la '/tmp/qq/lib'
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.so.0.0.0 /tmp/qq/lib/libsyscall.so.0.0.0
libtool: install: (cd /tmp/qq/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so.0 || { rm -f libsyscall.so.0 && ln -s libsyscall.so.0.0.0 libsyscall.so.0; }; })
libtool: install: (cd /tmp/qq/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so || { rm -f libsyscall.so && ln -s libsyscall.so.0.0.0 libsyscall.so; }; })
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.lai /tmp/qq/lib/libsyscall.la
libtool: finish: PATH="/home/user/.gemie/bin:/home/user/bin:/usr/bin:/bin:/usr/local/bin:/usr/games:/sbin" ldconfig -n /tmp/qq/lib
----------------------------------------------------------------------
Libraries have been installed in:
  /tmp/qq/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the '-LLIBDIR'
flag during linking and do at least one of the following:
  - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable
    during execution
  - add LIBDIR to the 'LD_RUN_PATH' environment variable
    during linking
  - use the '-Wl,-rpath -Wl,LIBDIR' linker flag
  - have your system administrator add LIBDIR to '/etc/ld.so.conf'

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
/usr/bin/mkdir -p '/tmp/qq/bin'
 /bin/sh ../libtool   --mode=install /usr/bin/ginstall -c syscall '/tmp/qq/bin'
libtool: install: /usr/bin/ginstall -c .libs/syscall /tmp/qq/bin/syscall
/usr/bin/mkdir -p '/tmp/qq/share/man/man1'
/usr/bin/ginstall -c -m 644 syscall.1 '/tmp/qq/share/man/man1'

[user@VM syscall-master]$ tree /tmp/qq
/tmp/qq
├── bin
│   └── syscall
├── lib
│   ├── libsyscall.la
│   ├── libsyscall.so -> libsyscall.so.0.0.0
│   ├── libsyscall.so.0 -> libsyscall.so.0.0.0
│   └── libsyscall.so.0.0.0
└── share
   └── man
       └── man1
           └── syscall.1

6 directories, 6 files
[user@VM syscall-master]$
```

Место установки можно указать и на более раннем этапе — при оформлении `configure.ac`. Для этого в Autotools предусмотрены специальные макросы:
 + `AC_PREFIX_DEFAULT(<каталог>)` используется для явного указания пути установки по умолчанию взамен `/usr/local`;
 + `AC_PREFIX_PROGRAM(<путь>)` позволяет указать не явный путь установки, а уже установленную программу для использования её места установки (если он описан в PATH). Например,  если программой выбрана `gcc`, и PATH содержит путь к `/usr/local/gnu/bin/gcc`, путём установки будет выбран `/usr/local/gnu`.

`@user`: `syscall-master/configure.ac`

```
<...>
AM_INIT_AUTOMAKE([foreign subdir-objects])
LT_INIT([disable-static])
AC_CONFIG_HEADERS([config.h])

AC_PREFIX_DEFAULT([/tmp/QKRQ])

DX_INIT_DOXYGEN([syscall], [Doxyfile], [doxygen-doc])
<...>
```

`@user`
```console
[user@VM syscall-master]$ autoreconf -fisv
<...>
[user@VM syscall-master]$ ./configure
<...>
[user@VM syscall-master]$ make install
Making install in src
<...>
/usr/bin/mkdir -p '/tmp/QKRQ/lib'
/bin/sh ../libtool   --mode=install /usr/bin/ginstall -c   libsyscall.la '/tmp/QKRQ/lib'
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.so.0.0.0 /tmp/QKRQ/lib/libsyscall.so.0.0.0
libtool: install: (cd /tmp/QKRQ/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so.0 || { rm -f libsyscall.so.0 && ln -s libsyscall.so.0.0.0 libsyscall.so.0; }; })
libtool: install: (cd /tmp/QKRQ/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so || { rm -f libsyscall.so && ln -s libsyscall.so.0.0.0 libsyscall.so; }; })
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.lai /tmp/QKRQ/lib/libsyscall.la
libtool: finish: PATH="/home/user/.gemie/bin:/home/user/bin:/usr/bin:/bin:/usr/local/bin:/usr/games:/sbin" ldconfig -n /tmp/QKRQ/lib
----------------------------------------------------------------------
Libraries have been installed in:
  /tmp/QKRQ/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the '-LLIBDIR'
flag during linking and do at least one of the following:
  - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable
    during execution
  - add LIBDIR to the 'LD_RUN_PATH' environment variable
    during linking
  - use the '-Wl,-rpath -Wl,LIBDIR' linker flag
  - have your system administrator add LIBDIR to '/etc/ld.so.conf'

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
/usr/bin/mkdir -p '/tmp/QKRQ/bin'
 /bin/sh ../libtool   --mode=install /usr/bin/ginstall -c syscall '/tmp/QKRQ/bin'
libtool: install: /usr/bin/ginstall -c .libs/syscall /tmp/QKRQ/bin/syscall
/usr/bin/mkdir -p '/tmp/QKRQ/share/man/man1'
/usr/bin/ginstall -c -m 644 syscall.1 '/tmp/QKRQ/share/man/man1'

[user@VM syscall-master]$ tree tmp
tmp  [error opening dir]

0 directories, 0 files
[user@VM syscall-master]$ tree /tmp
/tmp
├── QKRQ
│   ├── bin
│   │   └── syscall
│   ├── lib
│   │   ├── libsyscall.la
│   │   ├── libsyscall.so -> libsyscall.so.0.0.0
│   │   ├── libsyscall.so.0 -> libsyscall.so.0.0.0
│   │   └── libsyscall.so.0.0.0
│   └── share
│       └── man
│           └── man1
│               └── syscall.1
├── qq
│   ├── bin
│   │   └── syscall
│   ├── lib
│   │   ├── libsyscall.la
│   │   ├── libsyscall.so -> libsyscall.so.0.0.0
│   │   ├── libsyscall.so.0 -> libsyscall.so.0.0.0
│   │   └── libsyscall.so.0.0.0
│   └── share
│       └── man
│           └── man1
│               └── syscall.1
├── systemd-private-cf21b62e498d45469bbfe8c619515c2b-chronyd.service-1UNCOt  [error opening dir]
└── systemd-private-cf21b62e498d45469bbfe8c619515c2b-systemd-logind.service-pFMnpU  [error opening dir]

15 directories, 12 files
[user@VM syscall-master]$
```
## Собственный репозиторий

Одним из преимуществ работы работы с Gear и Hasher является автоматическое ведение собственного репозитория пакетов, собираемых в системе. Каталог с установочными пакетами и с пакетами с исходниками находится в специальной директории `~/hasher/repo/`

`@user`
```console
[user@VM ~]$ tree ~/hasher/repo/
/home/user/hasher/repo/
├── SRPMS.hasher
│   ├── autoenv-pkg-1.0-alt1.src.rpm
│   ├── autoenv-pkg-1.1-alt1.src.rpm
│   ├── double-1.0-alt1.src.rpm
│   ├── gdb-check-pkg-1.0-alt1.src.rpm
│   ├── GNU_picture-1.0-alt1.src.rpm
│   ├── hello-upgrade-1.0-alt1.src.rpm
│   ├── inc-1.0-alt1.src.rpm
│   ├── Multilab-1.0-alt1.src.rpm
│   ├── not-null-pkg-1.0-alt1.src.rpm
│   ├── null-pkg-1.0-alt1.src.rpm
│   ├── pkg-ncurses-1.0-alt1.src.rpm
│   ├── regex-pkg-1.0-alt1.src.rpm
│   ├── sheepcounter-0.0-alt1.src.rpm
│   ├── sheepcounter-1.0-alt1.src.rpm
│   ├── sheepcounter-pkg-1.0-alt1.src.rpm
│   ├── strace-pkg-1.0-alt1.src.rpm
│   ├── syscall-1.0-alt1.src.rpm
│   ├── syscall-1.1-alt1.src.rpm
│   ├── syscall-1.2-alt1.src.rpm
│   ├── syscall-1.3-alt1.src.rpm
│   ├── todo-pkg-1.0-alt1.src.rpm
│   └── Weatherminal-1.0-alt1.src.rpm
└── x86_64
   └── RPMS.hasher
       ├── autoenv-pkg-1.0-alt1.x86_64.rpm
       ├── autoenv-pkg-1.1-alt1.x86_64.rpm
       ├── autoenv-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── autoenv-pkg-debuginfo-1.1-alt1.x86_64.rpm
       ├── double-1.0-alt1.x86_64.rpm
       ├── double-second-1.0-alt1.x86_64.rpm
       ├── gdb-check-pkg-1.0-alt1.x86_64.rpm
       ├── gdb-check-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── GNU_picture-1.0-alt1.x86_64.rpm
       ├── GNU_picture-data-1.0-alt1.noarch.rpm
       ├── GNU_picture-data-1.0-alt1.x86_64.rpm
       ├── GNU_picture-debuginfo-1.0-alt1.x86_64.rpm
       ├── hello-upgrade-1.0-alt1.x86_64.rpm
       ├── hello-upgrade-debuginfo-1.0-alt1.x86_64.rpm
       ├── inc-1.0-alt1.x86_64.rpm
       ├── inc-debuginfo-1.0-alt1.x86_64.rpm
       ├── Multilab-1.0-alt1.x86_64.rpm
       ├── Multilab-debuginfo-1.0-alt1.x86_64.rpm
       ├── not-null-pkg-1.0-alt1.x86_64.rpm
       ├── null-pkg-1.0-alt1.x86_64.rpm
       ├── pkg-ncurses-1.0-alt1.x86_64.rpm
       ├── pkg-ncurses-debuginfo-1.0-alt1.x86_64.rpm
       ├── regex-pkg-1.0-alt1.x86_64.rpm
       ├── regex-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── sheepcounter-0.0-alt1.x86_64.rpm
       ├── sheepcounter-1.0-alt1.x86_64.rpm
       ├── sheepcounter-debuginfo-0.0-alt1.x86_64.rpm
       ├── sheepcounter-debuginfo-1.0-alt1.x86_64.rpm
       ├── sheepcounter-pkg-1.0-alt1.x86_64.rpm
       ├── sheepcounter-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── strace-pkg-1.0-alt1.x86_64.rpm
       ├── strace-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── syscall-1.0-alt1.x86_64.rpm
       ├── syscall-1.1-alt1.x86_64.rpm
       ├── syscall-1.2-alt1.x86_64.rpm
       ├── syscall-1.3-alt1.x86_64.rpm
       ├── syscall-debuginfo-1.0-alt1.x86_64.rpm
       ├── syscall-debuginfo-1.1-alt1.x86_64.rpm
       ├── syscall-debuginfo-1.2-alt1.x86_64.rpm
       ├── syscall-debuginfo-1.3-alt1.x86_64.rpm
       ├── todo-pkg-1.0-alt1.x86_64.rpm
       └── Weatherminal-1.0-alt1.x86_64.rpm

4 directories, 64 files
[user@VM ~]$
```

При успешной пересборке пакета с помощью hasher _в чистом окружении_ (не изнутри hasher с помощью `rpmbuild`, а через Gear (`gear-hsh`) или с помощью `hsh <name>.src.rpm`) содержимое этих каталогов автоматически обновляется.

`@user`
```console
[user@VM ~]$ ls -la ~/hasher/repo/x86_64/RPMS.hasher/null-pkg-1.0-alt1.x86_64.rpm
-rw-r--r-- 1 user_b user_b 1377 июл  9 21:13 /home/user/hasher/repo/x86_64/RPMS.hasher/null-pkg-1.0-alt1.x86_64.rpm

[user@VM ~]$ hsh ~/hasher/repo/SRPMS.hasher/null-pkg-1.0-alt1.src.rpm
<86>Aug 23 08:29:47 userdel[1115812]: delete user 'rooter'
<86>Aug 23 08:29:47 userdel[1115812]: removed group 'rooter' owned by 'rooter'
<86>Aug 23 08:29:48 groupadd[1115819]: group added to /etc/group: name=rooter, GID=1003
<86>Aug 23 08:29:48 groupadd[1115819]: group added to /etc/gshadow: name=rooter
<86>Aug 23 08:29:48 groupadd[1115819]: new group: name=rooter, GID=1003
<86>Aug 23 08:29:48 useradd[1115825]: new user: name=rooter, UID=1003, GID=1003, home=/root, shell=/bin/bash, from=none
<86>Aug 23 08:29:48 userdel[1115835]: delete user 'builder'
<86>Aug 23 08:29:48 userdel[1115835]: removed group 'builder' owned by 'builder'
<86>Aug 23 08:29:48 userdel[1115835]: removed shadow group 'builder' owned by 'builder'
<86>Aug 23 08:29:49 groupadd[1115842]: group added to /etc/group: name=builder, GID=1004
<86>Aug 23 08:29:49 groupadd[1115842]: group added to /etc/gshadow: name=builder
<86>Aug 23 08:29:49 groupadd[1115842]: new group: name=builder, GID=1004
<86>Aug 23 08:29:49 useradd[1115848]: new user: name=builder, UID=1004, GID=1004, home=/usr/src, shell=/bin/bash, from=none
Building target platforms: x86_64
Building for target x86_64
Wrote: /usr/src/in/nosrpm/null-pkg-1.0-alt1.src.rpm (w1.gzdio)
Installing null-pkg-1.0-alt1.src.rpm
Building target platforms: x86_64
Building for target x86_64
Processing files: null-pkg-1.0-alt1
Wrote: /usr/src/RPM/SRPMS/null-pkg-1.0-alt1.src.rpm (w2.lzdio)
Wrote: /usr/src/RPM/RPMS/x86_64/null-pkg-1.0-alt1.x86_64.rpm (w2.lzdio)
0.01user 0.01system 0:00.02elapsed 96%CPU (0avgtext+0avgdata 5900maxresident)k
0inputs+40outputs (0major+1010minor)pagefaults 0swaps

[user@VM ~]$ ls -la ~/hasher/repo/x86_64/RPMS.hasher/null-pkg-1.0-alt1.x86_64.rpm
-rw-r--r-- 1 user_d user_d 1377 авг 23 11:29 /home/user/hasher/repo/x86_64/RPMS.hasher/null-pkg-1.0-alt1.x86_64.rpm
[user@VM ~]$
```

Каталог `/home/user/hasher/repo` может вполне выступать в качестве дополнительного _репозитория_ пакетов системы. Обновление из такого репозитория будет происходить даже при совпадении версий: в пакете зафиксировано время сборки, и более новым считается собранный позже.

Все пути к преднастроенным репозиториям, используемым в системе, хранятся в файлах `/etc/apt/sources.list` и `/etc/apt/sources.list/*.list`. [Формат описания репозитория](https://www.altlinux.org/%D0%9F%D1%83%D1%82%D0%B8%D0%9A%D0%A0%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F%D0%BC) в файле следующий:

 - Способ организации (тип) репозитория;
 - (_необязательный_) Ключ, которым подписаны индексы;
 - URL хранилища;
 - Архитектура;
 - Раздел.

`@user`
```console
[user@VM ~]$ cat /etc/apt/sources.list
# Local package resource list for APT goes here.
# To inspect package defined part, see /etc/apt/sources.list.d/*.list

[user@VM ~]$ ls /etc/apt/sources.list.d/
alt.list  heanet.list  ipsl.list  yandex.list

[user@VM ~]$ cat /etc/apt/sources.list.d/alt.list
# ftp.altlinux.org (ALT Linux, Moscow)

# ALT Platform 11
#rpm [p11] ftp://ftp.altlinux.org/pub/distributions/ALTLinux p11/branch/x86_64 classic
#rpm [p11] ftp://ftp.altlinux.org/pub/distributions/ALTLinux p11/branch/x86_64-i586 classic
#rpm [p11] ftp://ftp.altlinux.org/pub/distributions/ALTLinux p11/branch/noarch classic

rpm [p11] http://ftp.altlinux.org/pub/distributions/ALTLinux p11/branch/x86_64 classic
rpm [p11] http://ftp.altlinux.org/pub/distributions/ALTLinux p11/branch/x86_64-i586 classic
rpm [p11] http://ftp.altlinux.org/pub/distributions/ALTLinux p11/branch/noarch classic

#rpm [p11] rsync://ftp.altlinux.org/ALTLinux p11/branch/x86_64 classic
#rpm [p11] rsync://ftp.altlinux.org/ALTLinux p11/branch/x86_64-i586 classic
#rpm [p11] rsync://ftp.altlinux.org/ALTLinux p11/branch/noarch classic

[user@VM ~]$
```

Локальный репозиторий — например, для разработчика, который что-то правит в пакете и тут же проверяет результат — можно оформить прямо в каталоге `/home/user/hasher/repo`: добавить его в список доступных репозиториев напрямую, с типом `rpm-dir` (репозиторий без индекса).

`@user`
```console
[user@VM ~]$ su -
Password:
[root@VM ~]# vim /etc/apt/sources.list
[root@VM ~]#
выход
[user@VM ~]$ cat /etc/apt/sources.list
# Local package resource list for APT goes here.
# To inspect package defined part, see /etc/apt/sources.list.d/*.list

rpm-dir file:///home/user/hasher repo/x86_64 hasher
[user@VM ~]$
```

Теперь можно пользоваться репозиторием, как и другими — устанавливать пакеты с помощью пакетных менеджеров:

`@root`
```console
[root@VM ~]# apt-repo
rpm-dir file:///home/user/hasher repo/x86_64 hasher
rpm [p11] http://ftp.altlinux.org/pub/distributions/ALTLinux p11/branch/x86_64 classic
rpm [p11] http://ftp.altlinux.org/pub/distributions/ALTLinux p11/branch/x86_64-i586 classic
rpm [p11] http://ftp.altlinux.org/pub/distributions/ALTLinux p11/branch/noarch classic

[root@VM ~]# apt-get install not-null-pkg
Чтение списков пакетов... Завершено
Построение дерева зависимостей... Завершено
Следующие НОВЫЕ пакеты будут установлены:
 not-null-pkg
0 будет обновлено, 1 новых установлено, 0 пакетов будет удалено и 60 не будет обновлено.
Необходимо получить 0B/1845B архивов.
После распаковки потребуется дополнительно 29B дискового пространства.
Совершаем изменения...
Подготовка...            #################################################################### [100%]
Обновление / установка...
1: not-null-pkg-1.0-alt1 #################################################################### [100%]
Завершено.
[root@VM ~]# not-null-pkg
This is not null pkg
[root@VM ~]#
```

Этот репозиторий по умолчанию уже включён в сам `hasher`, именно поэтому только что собранные пакеты можно немедленно устанавливать с помощью `hsh-install`.

### Репозиторий и индексами

Просматривая репозиторий без индексов (в которых хранится информация о зависимостях, конфликтах, времени сборки и т. д.), APT будет регулярно строить их динамически. Если пакетов в нём достаточно, это может занимать довольно много времени. Кроме того, без индексов не будет работать доступ по сети.

Создать стандартный репозиторий типа `rpm` [довольно просто](https://www.altlinux.org/%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%BE%D0%B1%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE_%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F).

Репозиторий APT типа `prm` состоит из двух компонентов: _индексов_, где описаны все пакеты, ссылки на них и их версии, и _самих `.rpm`-пакетов_.

Каталог для репозитория создаётся по особым правилам:
 + В каталоге должно быть хранилище пакетов в формате `…/Раздел/RPMS.Компонент`
	 + `Раздел` — описание архитектуры хранимых пакетов. Ограничений на его именование нет, однако обычно оно соответствует аппаратной архитектуре, под которую собран пакет — `x86_64`, `aarch64` и т. д. для архитектурно зависимых пакетов, `noarch` — для архитектурно независимых.
	 + `Компонент` используется для классификации и организации пакетов в репозитории по функциональности или назначению. Ограничений на его именование нет
	 + `RPMS.Компонент` — непосредственно каталог с пакетами

`@user`
```console
[user@VM ~]$ mkdir NewRepo
[user@VM ~]$ cd NewRepo/
[user@VM NewRepo]$ mkdir -p x86_64/RPMS.classic
[user@VM NewRepo]$ cp ~/hasher/repo/x86_64/RPMS.hasher/* x86_64/RPMS.classic/
[user@VM NewRepo]$ tree
.
└── x86_64
   └── RPMS.classic
       ├── autoenv-pkg-1.0-alt1.x86_64.rpm
       ├── autoenv-pkg-1.1-alt1.x86_64.rpm
       ├── autoenv-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── autoenv-pkg-debuginfo-1.1-alt1.x86_64.rpm
       ├── double-1.0-alt1.x86_64.rpm
       ├── double-second-1.0-alt1.x86_64.rpm
       ├── gdb-check-pkg-1.0-alt1.x86_64.rpm
       ├── gdb-check-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── GNU_picture-1.0-alt1.x86_64.rpm
       ├── GNU_picture-data-1.0-alt1.noarch.rpm
       ├── GNU_picture-data-1.0-alt1.x86_64.rpm
       ├── GNU_picture-debuginfo-1.0-alt1.x86_64.rpm
       ├── hello-upgrade-1.0-alt1.x86_64.rpm
       ├── hello-upgrade-debuginfo-1.0-alt1.x86_64.rpm
       ├── inc-1.0-alt1.x86_64.rpm
       ├── inc-debuginfo-1.0-alt1.x86_64.rpm
       ├── Multilab-1.0-alt1.x86_64.rpm
       ├── Multilab-debuginfo-1.0-alt1.x86_64.rpm
       ├── not-null-pkg-1.0-alt1.x86_64.rpm
       ├── null-pkg-1.0-alt1.x86_64.rpm
       ├── pkg-ncurses-1.0-alt1.x86_64.rpm
       ├── pkg-ncurses-debuginfo-1.0-alt1.x86_64.rpm
       ├── regex-pkg-1.0-alt1.x86_64.rpm
       ├── regex-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── sheepcounter-0.0-alt1.x86_64.rpm
       ├── sheepcounter-1.0-alt1.x86_64.rpm
       ├── sheepcounter-debuginfo-0.0-alt1.x86_64.rpm
       ├── sheepcounter-debuginfo-1.0-alt1.x86_64.rpm
       ├── sheepcounter-pkg-1.0-alt1.x86_64.rpm
       ├── sheepcounter-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── strace-pkg-1.0-alt1.x86_64.rpm
       ├── strace-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── syscall-1.0-alt1.x86_64.rpm
       ├── syscall-1.1-alt1.x86_64.rpm
       ├── syscall-1.2-alt1.x86_64.rpm
       ├── syscall-1.3-alt1.x86_64.rpm
       ├── syscall-debuginfo-1.0-alt1.x86_64.rpm
       ├── syscall-debuginfo-1.1-alt1.x86_64.rpm
       ├── syscall-debuginfo-1.2-alt1.x86_64.rpm
       ├── syscall-debuginfo-1.3-alt1.x86_64.rpm
       ├── todo-pkg-1.0-alt1.x86_64.rpm
       └── Weatherminal-1.0-alt1.x86_64.rpm

3 directories, 42 files
[user@VM NewRepo]$
```

Для создания индексов для репозитория используется пакет `apt-repo-tools` и утилита `genbasedir`, создающий индексы для пакетов одного раздела репозитория. Обратите внимание на то, `hasher` не определяет архитектурную зависимость пакета: для него они все `x86_64`. Также стоит заметить, что репозиторий формируется «в рабочем порядке», его непротиворечивость ничем не гарантирована (например, у нас образовалось два одноимённых пакета `GNU_picture-data` разной архитектуры).

`@user`
```console
[user@VM NewRepo]$ genbasedir --create --progress --topdir=. x86_64 classic
Creating base directory... done
Components: classic
Processing packages... RPMS.classic 42/42 42/42 done
Waiting for bzip2 and xz to finish... done
Creating component releases... classic done
Updating global release file... done
Appending MD5Sum... classic done
Appending BLAKE2b... classic done
All your base are belong to us!!!
[user@VM NewRepo]$ tree
.
└── x86_64
   ├── base
   │   ├── pkglist.classic
   │   ├── pkglist.classic.bz2
   │   ├── pkglist.classic.xz
   │   ├── release
   │   └── release.classic
   └── RPMS.classic
       ├── autoenv-pkg-1.0-alt1.x86_64.rpm
       ├── autoenv-pkg-1.1-alt1.x86_64.rpm
       ├── autoenv-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── autoenv-pkg-debuginfo-1.1-alt1.x86_64.rpm
       ├── double-1.0-alt1.x86_64.rpm
       ├── double-second-1.0-alt1.x86_64.rpm
       ├── gdb-check-pkg-1.0-alt1.x86_64.rpm
       ├── gdb-check-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── GNU_picture-1.0-alt1.x86_64.rpm
       ├── GNU_picture-data-1.0-alt1.noarch.rpm
       ├── GNU_picture-data-1.0-alt1.x86_64.rpm
       ├── GNU_picture-debuginfo-1.0-alt1.x86_64.rpm
       ├── hello-upgrade-1.0-alt1.x86_64.rpm
       ├── hello-upgrade-debuginfo-1.0-alt1.x86_64.rpm
       ├── inc-1.0-alt1.x86_64.rpm
       ├── inc-debuginfo-1.0-alt1.x86_64.rpm
       ├── Multilab-1.0-alt1.x86_64.rpm
       ├── Multilab-debuginfo-1.0-alt1.x86_64.rpm
       ├── not-null-pkg-1.0-alt1.x86_64.rpm
       ├── null-pkg-1.0-alt1.x86_64.rpm
       ├── pkg-ncurses-1.0-alt1.x86_64.rpm
       ├── pkg-ncurses-debuginfo-1.0-alt1.x86_64.rpm
       ├── regex-pkg-1.0-alt1.x86_64.rpm
       ├── regex-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── sheepcounter-0.0-alt1.x86_64.rpm
       ├── sheepcounter-1.0-alt1.x86_64.rpm
       ├── sheepcounter-debuginfo-0.0-alt1.x86_64.rpm
       ├── sheepcounter-debuginfo-1.0-alt1.x86_64.rpm
       ├── sheepcounter-pkg-1.0-alt1.x86_64.rpm
       ├── sheepcounter-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── strace-pkg-1.0-alt1.x86_64.rpm
       ├── strace-pkg-debuginfo-1.0-alt1.x86_64.rpm
       ├── syscall-1.0-alt1.x86_64.rpm
       ├── syscall-1.1-alt1.x86_64.rpm
       ├── syscall-1.2-alt1.x86_64.rpm
       ├── syscall-1.3-alt1.x86_64.rpm
       ├── syscall-debuginfo-1.0-alt1.x86_64.rpm
       ├── syscall-debuginfo-1.1-alt1.x86_64.rpm
       ├── syscall-debuginfo-1.2-alt1.x86_64.rpm
       ├── syscall-debuginfo-1.3-alt1.x86_64.rpm
       ├── todo-pkg-1.0-alt1.x86_64.rpm
       └── Weatherminal-1.0-alt1.x86_64.rpm

4 directories, 47 files
[user@VM NewRepo]$
```

Добавим репозиторий к другим доступным и проверим работу индексов:

`@root`
```console
[root@VM ~]# cat /etc/apt/sources.list
# Local package resource list for APT goes here.
# To inspect package defined part, see /etc/apt/sources.list.d/*.list

rpm-dir file:///home/user/NewRepo x86_64 classic

[root@VM ~]# apt-repo
rpm-dir file:///home/user/NewRepo x86_64 classic
rpm [p11] http://ftp.altlinux.org/pub/distributions/ALTLinux p11/branch/x86_64 classic
rpm [p11] http://ftp.altlinux.org/pub/distributions/ALTLinux p11/branch/x86_64-i586 classic
rpm [p11] http://ftp.altlinux.org/pub/distributions/ALTLinux p11/branch/noarch classic

[root@VM ~]# apt-cache search GNU_picture
GNU_picture-debuginfo - Print your special GNU picture (debug files)
GNU_picture-data - Your special GNU picture
GNU_picture - Print your special GNU picture
[root@VM ~]#
```

Соблюдая надлежащую дисциплину (например, вовремя удаляя устаревшие и неактуальные пакеты), репозиторий можно опубликовать и использовать для обновления нескольких систем.

Запись в `/etc/sources.list` примет вид:
```
rpm http://<адрес_сервера>/<путь_до_NewRepo> x86_64 classic
```

Протестируем репозиторий, запустив примитивный HTTP-сервер:

`@user`
```console
[user@VM NewRepo]$ python3 -m http.server -d .
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...

```

Добавим информацию о репозитории в `sources.list` (Заметим, что путь до репозитория в данном случае `"/."`, поскольку сервер развёрнут непосредственно в директории репозитория)

`@root2`
```console
[root@VM ~]# cat /etc/apt/sources.list
# Local package resource list for APT goes here.
# To inspect package defined part, see /etc/apt/sources.list.d/*.list

rpm http://0.0.0.0:8000 x86_64 classic
[root@VM ~]#
```


Обновим индексы с помощью `apt-get update`

`@root2`
```console
[root@VM ~]# apt-get update
Получено: 1 http://0.0.0.0:8000 x86_64 release [1068B]
Получено: 2 http://ftp.altlinux.org p11/branch/x86_64 release [4210B]
Получено: 3 http://ftp.altlinux.org p11/branch/x86_64-i586 release [1665B]
Получено: 4 http://ftp.altlinux.org p11/branch/noarch release [2831B]
Получено 9774B за 0s (119kB/s).
Получено: 1 http://0.0.0.0:8000 x86_64/classic pkglist [8276B]
Получено: 2 http://0.0.0.0:8000 x86_64/classic release [126B]
Найдено http://ftp.altlinux.org p11/branch/x86_64/classic pkglist
Найдено http://ftp.altlinux.org p11/branch/x86_64/classic release
Найдено http://ftp.altlinux.org p11/branch/x86_64-i586/classic pkglist
Найдено http://ftp.altlinux.org p11/branch/x86_64-i586/classic release
Найдено http://ftp.altlinux.org p11/branch/noarch/classic pkglist
Найдено http://ftp.altlinux.org p11/branch/noarch/classic release
Получено 8402B за 0s (363kB/s).
Чтение списков пакетов... Завершено
Построение дерева зависимостей... Завершено
[root@VM ~]#
```

Посмотрим информацию о локально собранных пакетах

`@root2`
```console
[root@VM ~]# apt-cache search autoenv
autoenv-pkg - Test pkg with autotool
autoenv-pkg-debuginfo - Test pkg with autotool (debug files)
[root@VM ~]#
```
